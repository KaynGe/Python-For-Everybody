1.列表中重复的数字 （剑指 offer 03）

找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。
请找出数组中任意一个重复的数字。

示例 1：
输入：[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

2. 杨辉三角 (leetcode 118)
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:
输入: 5
输出:
[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]

3. 不同路径 （leetcode 62）
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

示例 1：
输入：m = 3, n = 7
输出：28

示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例 3：
输入：m = 7, n = 3
输出：28

示例 4：
输入：m = 3, n = 3
输出：6

answer：
1.列表中重复的数字
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        hash = set()
        for num in nums:
            if num in hash: return num
            hash.add(num)
        return 0
        
2.杨辉三角
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = [[]] * numRows
        for i in range(numRows):
            res[i] = [1] * (i + 1)
            res[i][0] = res[i][i] = 1
            for j in range(1, i):
                res[i][j] = res[i - 1][j - 1] + res[i - 1][j]
        return res
  
3.不同路径
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1] * n
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[n - 1]
